// generated by NiceStateMachineGenerator v1.0.0.0

using System;

using SampleApp.Sip;

namespace SampleApp.Sip.Generated
{
    public partial class client__invite__udp: IDisposable
    {
        
        public delegate void TimerFiredCallback(ITimer timer);
        
        public interface ITimer: IDisposable
        {
            void StartOrReset(double timerDelaySeconds);
            void Stop();
        }
        
        public delegate ITimer CreateTimerDelegate(string timerName, TimerFiredCallback callback);
        
        
        public enum State
        {
            Calling_Start,
            Calling_Retransmit,
            Proceeding,
            Completed,
            Terminated,
        }
        
        /**<summary>INVITE sent</summary>*/
        public event Action OnStateEnter__Calling_Start;
        /**<summary>INVITE sent</summary>*/
        public event Action OnStateEnter__Calling_Retransmit;
        /**<summary>The client transaction MUST be destroyed the instant it enters the 'Terminated' state</summary>*/
        public event Action OnStateEnter__Terminated;
        
        /**<summary>Furthermore, the provisional response MUST be passed to the TU</summary>*/
        public event Action<t_packet> OnEventTraverse__SIP_1xx; 
        /**<summary>and the response MUST be passed up to the TU</summary>*/
        public event Action<t_packet> OnEventTraverse__SIP_2xx; 
        /**<summary>The client transaction MUST pass the received response up to the TU, and the client transaction MUST generate an ACK request</summary>*/
        public event Action<t_packet> OnEventTraverse__SIP_300_699; 
        /**<summary>Inform TU</summary>*/
        public event Action OnEventTraverse__TransportError; 
        /**<summary>the client transaction SHOULD inform the TU that a timeout has occurred.</summary>*/
        public event Action OnTimerTraverse__Timer_B; 
        /**<summary>Any retransmissions of the final response that are received while in the 'Completed' state MUST cause the ACK to be re-passed to the transport layer for retransmission, but the newly received response MUST NOT be passed up to the TU.</summary>*/
        public event Action<t_packet> OnEventTraverse__Completed__SIP_300_699; 
        
        private bool m_isDisposed = false;
        public event Action<string> OnLog;
        public event Action<State> OnStateEnter;
        private readonly ITimer Timer_A;
        private readonly ITimer Timer_A2;
        private readonly ITimer Timer_B;
        private readonly ITimer Timer_D;
        
        public State CurrentState { get; private set; } = State.Calling_Start;
        
        public client__invite__udp(CreateTimerDelegate createTimer)
        {
            this.Timer_A = createTimer("Timer_A", this.OnTimer);
            this.Timer_A2 = createTimer("Timer_A2", this.OnTimer);
            this.Timer_B = createTimer("Timer_B", this.OnTimer);
            this.Timer_D = createTimer("Timer_D", this.OnTimer);
        }
        
        public void Dispose()
        {
            if (!this.m_isDisposed)
            {
                this.Timer_A.Dispose();
                this.Timer_A2.Dispose();
                this.Timer_B.Dispose();
                this.Timer_D.Dispose();
                this.m_isDisposed = true;
            }
        }
        
        public void Start()
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("Start");
            this.CurrentState = State.Calling_Start;
            this.OnStateEnter?.Invoke(State.Calling_Start);
            this.Timer_A.StartOrReset(0.5);
            this.Timer_B.StartOrReset(32);
            OnStateEnter__Calling_Start?.Invoke();
        }
        
        private void OnTimer(ITimer timer)
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            switch (this.CurrentState)
            {
            case State.Calling_Start:
                if (timer == this.Timer_A)
                {
                    this.OnLog?.Invoke("OnTimer: Timer_A");
                    SetState(State.Calling_Retransmit);
                }
                else 
                if (timer == this.Timer_B)
                {
                    this.OnLog?.Invoke("OnTimer: Timer_B");
                    throw new Exception("Event Timer_B is forbidden in state " + this.CurrentState);
                }
                else 
                {
                    throw new Exception("Unexpected timer finish in state Calling_Start. Timer was " + timer);
                }
                break;
                
            case State.Calling_Retransmit:
                if (timer == this.Timer_A2)
                {
                    this.OnLog?.Invoke("OnTimer: Timer_A2");
                    SetState(State.Calling_Retransmit);
                }
                else 
                if (timer == this.Timer_B)
                {
                    this.OnLog?.Invoke("OnTimer: Timer_B");
                    OnTimerTraverse__Timer_B?.Invoke();
                    SetState(State.Terminated);
                }
                else 
                {
                    throw new Exception("Unexpected timer finish in state Calling_Retransmit. Timer was " + timer);
                }
                break;
                
            case State.Completed:
                if (timer == this.Timer_D)
                {
                    this.OnLog?.Invoke("OnTimer: Timer_D");
                    SetState(State.Terminated);
                }
                else 
                {
                    throw new Exception("Unexpected timer finish in state Completed. Timer was " + timer);
                }
                break;
                
            default:
                throw new Exception("No timer events expected in state " + this.CurrentState);
            }
        }
        
        public void ProcessEvent__SIP_1xx(t_packet packet)
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("Event: SIP_1xx");
            switch (this.CurrentState)
            {
            case State.Calling_Start:
                OnEventTraverse__SIP_1xx?.Invoke(packet);
                SetState(State.Proceeding);
                break;
                
            case State.Calling_Retransmit:
                OnEventTraverse__SIP_1xx?.Invoke(packet);
                SetState(State.Proceeding);
                break;
                
            case State.Proceeding:
                OnEventTraverse__SIP_1xx?.Invoke(packet);
                SetState(State.Proceeding);
                break;
                
            case State.Completed:
                throw new Exception("Event SIP_1xx is forbidden in state " + this.CurrentState);
                
            default:
                throw new Exception("Event SIP_1xx is not expected in state " + this.CurrentState);
            }
        }
        
        public void ProcessEvent__SIP_2xx(t_packet packet)
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("Event: SIP_2xx");
            switch (this.CurrentState)
            {
            case State.Calling_Start:
                OnEventTraverse__SIP_2xx?.Invoke(packet);
                SetState(State.Terminated);
                break;
                
            case State.Calling_Retransmit:
                OnEventTraverse__SIP_2xx?.Invoke(packet);
                SetState(State.Terminated);
                break;
                
            case State.Proceeding:
                OnEventTraverse__SIP_2xx?.Invoke(packet);
                SetState(State.Terminated);
                break;
                
            case State.Completed:
                throw new Exception("Event SIP_2xx is forbidden in state " + this.CurrentState);
                
            default:
                throw new Exception("Event SIP_2xx is not expected in state " + this.CurrentState);
            }
        }
        
        public void ProcessEvent__SIP_300_699(t_packet packet)
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("Event: SIP_300_699");
            switch (this.CurrentState)
            {
            case State.Calling_Start:
                OnEventTraverse__SIP_300_699?.Invoke(packet);
                SetState(State.Completed);
                break;
                
            case State.Calling_Retransmit:
                OnEventTraverse__SIP_300_699?.Invoke(packet);
                SetState(State.Completed);
                break;
                
            case State.Proceeding:
                OnEventTraverse__SIP_300_699?.Invoke(packet);
                SetState(State.Completed);
                break;
                
            case State.Completed:
                OnEventTraverse__Completed__SIP_300_699?.Invoke(packet);
                SetState(State.Completed);
                break;
                
            default:
                throw new Exception("Event SIP_300_699 is not expected in state " + this.CurrentState);
            }
        }
        
        public void ProcessEvent__TransportError()
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("Event: TransportError");
            switch (this.CurrentState)
            {
            case State.Calling_Start:
                OnEventTraverse__TransportError?.Invoke();
                SetState(State.Terminated);
                break;
                
            case State.Calling_Retransmit:
                OnEventTraverse__TransportError?.Invoke();
                SetState(State.Terminated);
                break;
                
            case State.Proceeding:
                OnEventTraverse__TransportError?.Invoke();
                SetState(State.Terminated);
                break;
                
            case State.Completed:
                OnEventTraverse__TransportError?.Invoke();
                SetState(State.Terminated);
                break;
                
            default:
                throw new Exception("Event TransportError is not expected in state " + this.CurrentState);
            }
        }
        
        private void SetState(State state)
        {
            if (this.m_isDisposed)
            {
                return;
            }
            
            this.OnLog?.Invoke("SetState: " + state);
            switch (state)
            {
            case State.Calling_Start:
                this.CurrentState = State.Calling_Start;
                this.OnStateEnter?.Invoke(State.Calling_Start);
                this.Timer_A.StartOrReset(0.5);
                this.Timer_B.StartOrReset(32);
                OnStateEnter__Calling_Start?.Invoke();
                break;
                
            case State.Calling_Retransmit:
                this.CurrentState = State.Calling_Retransmit;
                this.OnStateEnter?.Invoke(State.Calling_Retransmit);
                this.Timer_A.Stop();
                this.Timer_A2.StartOrReset(1);
                OnStateEnter__Calling_Retransmit?.Invoke();
                break;
                
            case State.Proceeding:
                this.CurrentState = State.Proceeding;
                this.OnStateEnter?.Invoke(State.Proceeding);
                this.Timer_A.Stop();
                this.Timer_A2.Stop();
                this.Timer_B.Stop();
                break;
                
            case State.Completed:
                this.CurrentState = State.Completed;
                this.OnStateEnter?.Invoke(State.Completed);
                this.Timer_A.Stop();
                this.Timer_A2.Stop();
                this.Timer_B.Stop();
                this.Timer_D.StartOrReset(32);
                break;
                
            case State.Terminated:
                this.CurrentState = State.Terminated;
                this.OnStateEnter?.Invoke(State.Terminated);
                OnStateEnter__Terminated?.Invoke();
                break;
                
            default:
                throw new Exception("Unexpected state " + state);
            }
        }
        
    }
}
