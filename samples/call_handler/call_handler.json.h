// generated by NiceStateMachineGenerator v1.0.0.0

#pragma once

#include <stdexcept>
#include <functional>
#include <optional>


namespace generated
{
    
    template<class T>
    concept Timer = requires(T t) {
        { t.StartOrReset(double timerDelaySeconds) };
        { t.Stop() };
    };
    
    template<Timer T>
    using TimerFiredCallback = void(*)(const T* timer);
    
    template<Timer T>
    using TimerFactory = T*(*)(const char* timerName, TimerFiredCallback<T> callback);
    
    
    template <Timer T>
    class call_handler
    {
    public:
        enum class State
        {
            in_call,
            session_termination_process,
            awaiting_asr_fully_finalized,
            asr_fully_finalized,
            early_termination,
            termination,
        };
        
        /*sipCall.Stop()*/
        std::function<void()> OnStateEnter__session_termination_process;
        /*asr.SendFinalized()*/
        std::function<void()> OnStateEnter__awaiting_asr_fully_finalized;
        /*stateMachine.OnExternalEvent(DialogTerminated)*/
        std::function<void()> OnStateEnter__asr_fully_finalized;
        /*warn*/
        std::function<void()> OnStateEnter__early_termination;
        /*productionPlugin.WriteSessionToDb*/
        std::function<void()> OnStateEnter__termination;
        
        
    private:
        State m_currentState = State::in_call;
        T* asr_timeout;
        
    public:
        call_handler(TimerFactory<T> timerFactory)
        {
            TimerFiredCallback<T> timerCallback = std::bind(&call_handler::OnTimer, this, std::placeholders::_1);
            asr_timeout = timerFactory("asr_timeout", timerCallback);
        }
        
        ~call_handler()
        {
            delete asr_timeout;
        }
        
        State GetCurrentState()
        {
            return m_currentState;
        }
        
        void Start()
        {
            m_currentState = State::in_call;
        }
        
        void ProcessEvent__telephony_session_terminated()
        {
            switch (m_currentState)
            {
            case State::in_call:
                SetState(State::awaiting_asr_fully_finalized);
                break;
                
            case State::session_termination_process:
                SetState(State::awaiting_asr_fully_finalized);
                break;
                
            default:
                throw std::runtime_error("Event telephony_session_terminated is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__asr_fully_finalized()
        {
            switch (m_currentState)
            {
            case State::awaiting_asr_fully_finalized:
                SetState(State::asr_fully_finalized);
                break;
                
            case State::asr_fully_finalized:
                break;
                
            default:
                throw std::runtime_error("Event asr_fully_finalized is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__script_final_state_reached()
        {
            switch (m_currentState)
            {
            case State::in_call:
                SetState(State::early_termination);
                break;
                
            case State::session_termination_process:
                SetState(State::early_termination);
                break;
                
            case State::awaiting_asr_fully_finalized:
                SetState(State::early_termination);
                break;
                
            case State::asr_fully_finalized:
                SetState(State::termination);
                break;
                
            default:
                throw std::runtime_error("Event script_final_state_reached is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__session_termination_request()
        {
            switch (m_currentState)
            {
            case State::in_call:
                SetState(State::session_termination_process);
                break;
                
            case State::session_termination_process:
                break;
                
            case State::awaiting_asr_fully_finalized:
                break;
                
            case State::asr_fully_finalized:
                break;
                
            default:
                throw std::runtime_error("Event session_termination_request is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
    private:
        void OnTimer(T* timer)
        {
            switch (m_currentState)
            {
            case State::awaiting_asr_fully_finalized:
                if (timer == asr_timeout)
                {
                    SetState(State::asr_fully_finalized);
                }
                else 
                {
                    throw std::runtime_error("Unexpected timer finish in state awaiting_asr_fully_finalized");
                }
                break;
                
            default:
                throw std::runtime_error("No timer events expected in current state" /*+ this.CurrentState*/);
            }
        }
        
        void SetState(State state)
        {
            switch (state)
            {
            case State::in_call:
                m_currentState = State::in_call;
                break;
                
            case State::session_termination_process:
                m_currentState = State::session_termination_process;
                if (OnStateEnter__session_termination_process) { OnStateEnter__session_termination_process(); }
                break;
                
            case State::awaiting_asr_fully_finalized:
                m_currentState = State::awaiting_asr_fully_finalized;
                asr_timeout->StartOrReset(10);
                if (OnStateEnter__awaiting_asr_fully_finalized) { OnStateEnter__awaiting_asr_fully_finalized(); }
                break;
                
            case State::asr_fully_finalized:
                m_currentState = State::asr_fully_finalized;
                asr_timeout->Stop();
                if (OnStateEnter__asr_fully_finalized) { OnStateEnter__asr_fully_finalized(); }
                break;
                
            case State::early_termination:
                m_currentState = State::early_termination;
                if (OnStateEnter__early_termination) { OnStateEnter__early_termination(); }
                SetState(State::termination);
                break;
                
            case State::termination:
                m_currentState = State::termination;
                if (OnStateEnter__termination) { OnStateEnter__termination(); }
                break;
                
            default:
                throw std::runtime_error("Unexpected state " /* + state*/);
            }
        }
        
    };
}
